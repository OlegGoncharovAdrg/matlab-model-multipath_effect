clear; close all; clc;
%% Анализ свойств многолучевости навигационных сигналов

% Блок ввода входных параметров:
f = 4*1.023; % Мгц, тактовая частота кода перспективного сигнала ГЛОНАСС
N = [-1 1 -1 -1 -1 -1 1 1 -1 -1 1 1 -1 1 1 1 1 1 1 -1 1 -1 -1 -1 -1 1 1 -1 1 1 1 -1 1]; % ПСП последовательность
d = 10e2/f; % длительность чипа в нс (ДЛЯ ПЕРСПЕКТИВНОГО ГЛОНАСС С ЧАСТОТОЙ 4*1.023Мгц
ds = d/20; % длительность строба,нс (используется "простой" строб)
k = 4*d/ds; % коэффициент расширения ПСП последовательности (кол-ко дискретов на один чип ПСП)
m = 4; % частота следования чипов ВОС (коэффициент кратности меандровой последовательности)

b = length(N)*k; % определение длины вектора результирующей матрицы res
res = zeros(1,2*b);% матрица значений огибающей ошибки многолучевости
%% расширение входной ПСП
for qind=1:2
    Q=pi*(qind-1); %фаза пришедшего сигнала
    a=0.1*2*(1.5-qind);%коэффициент затухания пришедшего сигнала
for i = 0 : length(N) - 1 
    for j = 0 : k - 1
         X(i * k + j + 1) = N(i + 1);%расширяем ПСП в k раз 
    end
end

%% Формирование расширяющей последовательности для ВОС
 for i = 0 : length(N) - 1
    for j = 0 : k - 1
      G(i * k + j + 1) = 1 - mod(floor(j * m / k), 2) * 2;
    end
 end

%% Формирование ВОС как умножение вх.последовательности и расширяющей
for i=1:length(X)
    Xmod(i)=G(i)*X(i);%сигнал, который поступает на вход приемника
end

%% Формирование стробов
y = ones(1,length(Xmod)-1);
 for i=1:(length(Xmod)-1)
     if sign(Xmod(i))> sign(Xmod(i+1))
        y(i)=-1;
        y(i-1)=-1;
        y(i+1)=-1;
        y(i+2)=-1;
     end
     if sign(Xmod(i))< sign(Xmod(i+1))
         y(i)=1;
         y(i-1)=1;
         y(i+1)=1;
         y(i+2)=1;
     end
 end
%% Нахождение значений матрицы res огибающей ошибки многолучевости
Ro=xcorr(Xmod);%АКФ опорного сигнала и сигнала, пришедшего без задержки (без ошибок)
deltaR=xcorr(Xmod,y);% ВКФ опорного сигнала и стробовой последовательности 
 for sigma=0:k    %величина запаздывания сигнала
 for i=1:(length(Xmod))
     if sigma>=i 
         X2(i)=Xmod(i);
     else
         X2(i)=Xmod(i)+a*Xmod(i-sigma);
         % сигнал,как сумма "прямого" и "отраженного" сигнала
     end
 end

     Ro2=xcorr(Xmod,X2);% ВКФ "прямого" сигнала и "отраженного"
     deltaR2=xcorr(y,X2);%ВКФ стробовой последовательности и "отраженного" сигнала
     
   %%Нахождение дискриминационной характеристики
     Z1=1/(1+((a*sin(Q)*Ro2)/(Ro+a*cos(Q)*Ro2)).^2);%составляющая ДХ
     Z2=deltaR+a*cos(Q)*deltaR2+(a*sin(Q))^2*(deltaR2.*Ro2)/(Ro+Ro2*a*cos(Q));
     Z3=Ro+a*cos(Q)*Ro2+(a*sin(Q))^2*Ro2.^2/(Ro+Ro2*a*cos(Q));
     Zdc=Z1.*Z2.*Z3;%выходная величина когерентного дискриминатора (ДХ)
     
     %%Поиск ошибки многолучевости как корень уравнения Zdc=0 (используется
     %%аналитический метод)
     zmax1 = -1000000000;
     c1=0;c2=0;c3=0;
for i=1:length(Zdc)-1 %находим максимум ДХ
    if Zdc(i)> zmax1 
      c1 = i; %абсцисса точки максимума
      zmax1 = Zdc(i);% ордината точки максимума
    end
end   

 for j=c1:-1:2%находим решение как пересечение ДХ с нулем
    if sign(Zdc(j)) > sign(Zdc(j-1))
      c2=j-1;%абцисса точки меньше нуля
      c3=j;%абцисса точки больше нуля
      zmax2=Zdc(j-1);%ордината точки меньше нуля
      zmax3=Zdc(j);%ордината точки больше нуля
      res(qind,sigma+1)=-zmax2*(c3-c2)/(zmax3-zmax2)+c2;
      %составление уравнения прямой из точек с2,с3,zmax2,zmax3 и поиск ее пересечения с нулем
          if sigma > 0 
             res(qind,sigma+1) = res(qind,sigma+1) - res(qind,1);
             %составление результирующей матрицы значений огибающей ошибки многолучевости
          end
          break
    end
 end
 end
 res(qind,1)=0;
 
 for i=1:length(res)
  result_x(qind,i)=((10^-5)*res(qind,i)*3*(10e8)/k);%масштабирование оси ординат
  result_y(qind,i)= (d*i)/k;%масштабирование оси абсцисс, нс
 end
 
end

%% Графическое отображение огибающей ошибки многолучевости

multipath_delay_zero_phase_y=(result_x(1,1:length(result_x)));
% значения ошибки многолучевости для сигнала пришедшего с фазой ноль
multipath_delay_zero_phase_x=result_y(1,1:length(result_y));
multipath_delay_pi_phase_y=(result_x(2,1:length(result_x)));
% значения ошибки многолучевости для сигнала пришедшего с фазой "ПИ"
multipath_delay_pi_phase_x=result_y(2,1:length(result_y));

figure(1);plot(multipath_delay_zero_phase_x,multipath_delay_zero_phase_y);
set(findobj(gca,'Type','line','Color',[0 0 1]),'Color','black','LineWidth',2);hold on;
plot(multipath_delay_pi_phase_x,multipath_delay_pi_phase_y);
legend('Q=0','Q=pi');
title('Огибающая ошибки многолучевости сигнала');
xlabel('Задержка сигнала,нс');
ylabel('Значение ошибки, м');
xlim([0 500]);